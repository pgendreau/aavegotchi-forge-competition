"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

type Account {
  id: Bytes!
  totalItemsForged: BigInt!
  totalItemsSmelted: BigInt!
}

input Account_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Account_filter]
  id: Bytes
  id_contains: Bytes
  id_gt: Bytes
  id_gte: Bytes
  id_in: [Bytes!]
  id_lt: Bytes
  id_lte: Bytes
  id_not: Bytes
  id_not_contains: Bytes
  id_not_in: [Bytes!]
  or: [Account_filter]
  totalItemsForged: BigInt
  totalItemsForged_gt: BigInt
  totalItemsForged_gte: BigInt
  totalItemsForged_in: [BigInt!]
  totalItemsForged_lt: BigInt
  totalItemsForged_lte: BigInt
  totalItemsForged_not: BigInt
  totalItemsForged_not_in: [BigInt!]
  totalItemsSmelted: BigInt
  totalItemsSmelted_gt: BigInt
  totalItemsSmelted_gte: BigInt
  totalItemsSmelted_in: [BigInt!]
  totalItemsSmelted_lt: BigInt
  totalItemsSmelted_lte: BigInt
  totalItemsSmelted_not: BigInt
  totalItemsSmelted_not_in: [BigInt!]
}

enum Account_orderBy {
  id
  totalItemsForged
  totalItemsSmelted
}

enum Aggregation_interval {
  day
  hour
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type ForgeQueueItem {
  gotchi: Gotchi!

  """ Gotchi ID + Item ID + Forge Queue Item ID """
  id: ID!
  isClaimed: Boolean!
  item: Item!

  """ Forge Queue Item ID """
  queueId: BigInt!
  readyBlock: BigInt!
}

input ForgeQueueItem_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ForgeQueueItem_filter]
  gotchi: String
  gotchi_: Gotchi_filter
  gotchi_contains: String
  gotchi_contains_nocase: String
  gotchi_ends_with: String
  gotchi_ends_with_nocase: String
  gotchi_gt: String
  gotchi_gte: String
  gotchi_in: [String!]
  gotchi_lt: String
  gotchi_lte: String
  gotchi_not: String
  gotchi_not_contains: String
  gotchi_not_contains_nocase: String
  gotchi_not_ends_with: String
  gotchi_not_ends_with_nocase: String
  gotchi_not_in: [String!]
  gotchi_not_starts_with: String
  gotchi_not_starts_with_nocase: String
  gotchi_starts_with: String
  gotchi_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isClaimed: Boolean
  isClaimed_in: [Boolean!]
  isClaimed_not: Boolean
  isClaimed_not_in: [Boolean!]
  item: String
  item_: Item_filter
  item_contains: String
  item_contains_nocase: String
  item_ends_with: String
  item_ends_with_nocase: String
  item_gt: String
  item_gte: String
  item_in: [String!]
  item_lt: String
  item_lte: String
  item_not: String
  item_not_contains: String
  item_not_contains_nocase: String
  item_not_ends_with: String
  item_not_ends_with_nocase: String
  item_not_in: [String!]
  item_not_starts_with: String
  item_not_starts_with_nocase: String
  item_starts_with: String
  item_starts_with_nocase: String
  or: [ForgeQueueItem_filter]
  queueId: BigInt
  queueId_gt: BigInt
  queueId_gte: BigInt
  queueId_in: [BigInt!]
  queueId_lt: BigInt
  queueId_lte: BigInt
  queueId_not: BigInt
  queueId_not_in: [BigInt!]
  readyBlock: BigInt
  readyBlock_gt: BigInt
  readyBlock_gte: BigInt
  readyBlock_in: [BigInt!]
  readyBlock_lt: BigInt
  readyBlock_lte: BigInt
  readyBlock_not: BigInt
  readyBlock_not_in: [BigInt!]
}

enum ForgeQueueItem_orderBy {
  gotchi
  gotchi__id
  gotchi__levelMultiplier
  gotchi__skillPoints
  gotchi__smithingLevel
  gotchi__totalItemsForged
  gotchi__totalItemsSmelted
  id
  isClaimed
  item
  item__id
  item__timesForged
  item__timesSmelted
  queueId
  readyBlock
}

type GeodeDraw {
  blockNumber: BigInt!
  geodeTokenId: BigInt!

  """ Tx hash + logIndex """
  id: ID!
  itemWon: Item
  requestId: Bytes!
  user: Account!
}

input GeodeDraw_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [GeodeDraw_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  geodeTokenId: BigInt
  geodeTokenId_gt: BigInt
  geodeTokenId_gte: BigInt
  geodeTokenId_in: [BigInt!]
  geodeTokenId_lt: BigInt
  geodeTokenId_lte: BigInt
  geodeTokenId_not: BigInt
  geodeTokenId_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  itemWon: String
  itemWon_: Item_filter
  itemWon_contains: String
  itemWon_contains_nocase: String
  itemWon_ends_with: String
  itemWon_ends_with_nocase: String
  itemWon_gt: String
  itemWon_gte: String
  itemWon_in: [String!]
  itemWon_lt: String
  itemWon_lte: String
  itemWon_not: String
  itemWon_not_contains: String
  itemWon_not_contains_nocase: String
  itemWon_not_ends_with: String
  itemWon_not_ends_with_nocase: String
  itemWon_not_in: [String!]
  itemWon_not_starts_with: String
  itemWon_not_starts_with_nocase: String
  itemWon_starts_with: String
  itemWon_starts_with_nocase: String
  or: [GeodeDraw_filter]
  requestId: Bytes
  requestId_contains: Bytes
  requestId_gt: Bytes
  requestId_gte: Bytes
  requestId_in: [Bytes!]
  requestId_lt: Bytes
  requestId_lte: Bytes
  requestId_not: Bytes
  requestId_not_contains: Bytes
  requestId_not_in: [Bytes!]
  user: String
  user_: Account_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum GeodeDraw_orderBy {
  blockNumber
  geodeTokenId
  id
  itemWon
  itemWon__id
  itemWon__timesForged
  itemWon__timesSmelted
  requestId
  user
  user__id
  user__totalItemsForged
  user__totalItemsSmelted
}

type GeodePrize {
  """ Geode Prize ID """
  id: ID!

  """ Total quantity """
  quantity: BigInt!

  """ Times empty """
  timesEmpty: BigInt!

  """ Times won """
  timesWon: BigInt!
}

input GeodePrize_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [GeodePrize_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [GeodePrize_filter]
  quantity: BigInt
  quantity_gt: BigInt
  quantity_gte: BigInt
  quantity_in: [BigInt!]
  quantity_lt: BigInt
  quantity_lte: BigInt
  quantity_not: BigInt
  quantity_not_in: [BigInt!]
  timesEmpty: BigInt
  timesEmpty_gt: BigInt
  timesEmpty_gte: BigInt
  timesEmpty_in: [BigInt!]
  timesEmpty_lt: BigInt
  timesEmpty_lte: BigInt
  timesEmpty_not: BigInt
  timesEmpty_not_in: [BigInt!]
  timesWon: BigInt
  timesWon_gt: BigInt
  timesWon_gte: BigInt
  timesWon_in: [BigInt!]
  timesWon_lt: BigInt
  timesWon_lte: BigInt
  timesWon_not: BigInt
  timesWon_not_in: [BigInt!]
}

enum GeodePrize_orderBy {
  id
  quantity
  timesEmpty
  timesWon
}

type GeodeRefund {
  blockNumber: BigInt!
  geodeTokenId: BigInt!

  """ Tx hash + logIndex """
  id: ID!
  requestId: Bytes!
  user: Account!
}

input GeodeRefund_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [GeodeRefund_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  geodeTokenId: BigInt
  geodeTokenId_gt: BigInt
  geodeTokenId_gte: BigInt
  geodeTokenId_in: [BigInt!]
  geodeTokenId_lt: BigInt
  geodeTokenId_lte: BigInt
  geodeTokenId_not: BigInt
  geodeTokenId_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [GeodeRefund_filter]
  requestId: Bytes
  requestId_contains: Bytes
  requestId_gt: Bytes
  requestId_gte: Bytes
  requestId_in: [Bytes!]
  requestId_lt: Bytes
  requestId_lte: Bytes
  requestId_not: Bytes
  requestId_not_contains: Bytes
  requestId_not_in: [Bytes!]
  user: String
  user_: Account_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum GeodeRefund_orderBy {
  blockNumber
  geodeTokenId
  id
  requestId
  user
  user__id
  user__totalItemsForged
  user__totalItemsSmelted
}

type Gotchi {
  id: ID!
  itemsForged(first: Int = 100, orderBy: ItemForged_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemForged_filter): [ItemForged!]
  itemsSmelted(first: Int = 100, orderBy: ItemSmelted_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemSmelted_filter): [ItemSmelted!]
  levelMultiplier: Int!
  skillPoints: Int!
  smithingLevel: Int!
  totalItemsForged: BigInt!
  totalItemsSmelted: BigInt!
}

input Gotchi_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Gotchi_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  itemsForged_: ItemForged_filter
  itemsSmelted_: ItemSmelted_filter
  levelMultiplier: Int
  levelMultiplier_gt: Int
  levelMultiplier_gte: Int
  levelMultiplier_in: [Int!]
  levelMultiplier_lt: Int
  levelMultiplier_lte: Int
  levelMultiplier_not: Int
  levelMultiplier_not_in: [Int!]
  or: [Gotchi_filter]
  skillPoints: Int
  skillPoints_gt: Int
  skillPoints_gte: Int
  skillPoints_in: [Int!]
  skillPoints_lt: Int
  skillPoints_lte: Int
  skillPoints_not: Int
  skillPoints_not_in: [Int!]
  smithingLevel: Int
  smithingLevel_gt: Int
  smithingLevel_gte: Int
  smithingLevel_in: [Int!]
  smithingLevel_lt: Int
  smithingLevel_lte: Int
  smithingLevel_not: Int
  smithingLevel_not_in: [Int!]
  totalItemsForged: BigInt
  totalItemsForged_gt: BigInt
  totalItemsForged_gte: BigInt
  totalItemsForged_in: [BigInt!]
  totalItemsForged_lt: BigInt
  totalItemsForged_lte: BigInt
  totalItemsForged_not: BigInt
  totalItemsForged_not_in: [BigInt!]
  totalItemsSmelted: BigInt
  totalItemsSmelted_gt: BigInt
  totalItemsSmelted_gte: BigInt
  totalItemsSmelted_in: [BigInt!]
  totalItemsSmelted_lt: BigInt
  totalItemsSmelted_lte: BigInt
  totalItemsSmelted_not: BigInt
  totalItemsSmelted_not_in: [BigInt!]
}

enum Gotchi_orderBy {
  id
  itemsForged
  itemsSmelted
  levelMultiplier
  skillPoints
  smithingLevel
  totalItemsForged
  totalItemsSmelted
}

"8 bytes signed integer\n"
scalar Int8

type Item {
  """ Item ID """
  id: ID!
  itemsForged(first: Int = 100, orderBy: ItemForged_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemForged_filter): [ItemForged!]
  itemsSmelted(first: Int = 100, orderBy: ItemSmelted_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ItemSmelted_filter): [ItemSmelted!]

  """ Number of times this item has been forged """
  timesForged: BigInt!

  """ Number of times this item has been smelted """
  timesSmelted: BigInt!
}

type ItemForged {
  gotchi: Gotchi!

  """ Tx hash + logIndex """
  id: ID!
  item: Item!
  timestamp: BigInt!
  txHash: Bytes!
}

input ItemForged_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ItemForged_filter]
  gotchi: String
  gotchi_: Gotchi_filter
  gotchi_contains: String
  gotchi_contains_nocase: String
  gotchi_ends_with: String
  gotchi_ends_with_nocase: String
  gotchi_gt: String
  gotchi_gte: String
  gotchi_in: [String!]
  gotchi_lt: String
  gotchi_lte: String
  gotchi_not: String
  gotchi_not_contains: String
  gotchi_not_contains_nocase: String
  gotchi_not_ends_with: String
  gotchi_not_ends_with_nocase: String
  gotchi_not_in: [String!]
  gotchi_not_starts_with: String
  gotchi_not_starts_with_nocase: String
  gotchi_starts_with: String
  gotchi_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  item: String
  item_: Item_filter
  item_contains: String
  item_contains_nocase: String
  item_ends_with: String
  item_ends_with_nocase: String
  item_gt: String
  item_gte: String
  item_in: [String!]
  item_lt: String
  item_lte: String
  item_not: String
  item_not_contains: String
  item_not_contains_nocase: String
  item_not_ends_with: String
  item_not_ends_with_nocase: String
  item_not_in: [String!]
  item_not_starts_with: String
  item_not_starts_with_nocase: String
  item_starts_with: String
  item_starts_with_nocase: String
  or: [ItemForged_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  txHash: Bytes
  txHash_contains: Bytes
  txHash_gt: Bytes
  txHash_gte: Bytes
  txHash_in: [Bytes!]
  txHash_lt: Bytes
  txHash_lte: Bytes
  txHash_not: Bytes
  txHash_not_contains: Bytes
  txHash_not_in: [Bytes!]
}

enum ItemForged_orderBy {
  gotchi
  gotchi__id
  gotchi__levelMultiplier
  gotchi__skillPoints
  gotchi__smithingLevel
  gotchi__totalItemsForged
  gotchi__totalItemsSmelted
  id
  item
  item__id
  item__timesForged
  item__timesSmelted
  timestamp
  txHash
}

type ItemSmelted {
  gotchi: Gotchi!

  """ Tx hash + logIndex """
  id: ID!
  item: Item!
  timestamp: BigInt!
  txHash: Bytes!
}

input ItemSmelted_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ItemSmelted_filter]
  gotchi: String
  gotchi_: Gotchi_filter
  gotchi_contains: String
  gotchi_contains_nocase: String
  gotchi_ends_with: String
  gotchi_ends_with_nocase: String
  gotchi_gt: String
  gotchi_gte: String
  gotchi_in: [String!]
  gotchi_lt: String
  gotchi_lte: String
  gotchi_not: String
  gotchi_not_contains: String
  gotchi_not_contains_nocase: String
  gotchi_not_ends_with: String
  gotchi_not_ends_with_nocase: String
  gotchi_not_in: [String!]
  gotchi_not_starts_with: String
  gotchi_not_starts_with_nocase: String
  gotchi_starts_with: String
  gotchi_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  item: String
  item_: Item_filter
  item_contains: String
  item_contains_nocase: String
  item_ends_with: String
  item_ends_with_nocase: String
  item_gt: String
  item_gte: String
  item_in: [String!]
  item_lt: String
  item_lte: String
  item_not: String
  item_not_contains: String
  item_not_contains_nocase: String
  item_not_ends_with: String
  item_not_ends_with_nocase: String
  item_not_in: [String!]
  item_not_starts_with: String
  item_not_starts_with_nocase: String
  item_starts_with: String
  item_starts_with_nocase: String
  or: [ItemSmelted_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  txHash: Bytes
  txHash_contains: Bytes
  txHash_gt: Bytes
  txHash_gte: Bytes
  txHash_in: [Bytes!]
  txHash_lt: Bytes
  txHash_lte: Bytes
  txHash_not: Bytes
  txHash_not_contains: Bytes
  txHash_not_in: [Bytes!]
}

enum ItemSmelted_orderBy {
  gotchi
  gotchi__id
  gotchi__levelMultiplier
  gotchi__skillPoints
  gotchi__smithingLevel
  gotchi__totalItemsForged
  gotchi__totalItemsSmelted
  id
  item
  item__id
  item__timesForged
  item__timesSmelted
  timestamp
  txHash
}

input Item_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Item_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  itemsForged_: ItemForged_filter
  itemsSmelted_: ItemSmelted_filter
  or: [Item_filter]
  timesForged: BigInt
  timesForged_gt: BigInt
  timesForged_gte: BigInt
  timesForged_in: [BigInt!]
  timesForged_lt: BigInt
  timesForged_lte: BigInt
  timesForged_not: BigInt
  timesForged_not_in: [BigInt!]
  timesSmelted: BigInt
  timesSmelted_gt: BigInt
  timesSmelted_gte: BigInt
  timesSmelted_in: [BigInt!]
  timesSmelted_lt: BigInt
  timesSmelted_lte: BigInt
  timesSmelted_not: BigInt
  timesSmelted_not_in: [BigInt!]
}

enum Item_orderBy {
  id
  itemsForged
  itemsSmelted
  timesForged
  timesSmelted
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  forgeQueueItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ForgeQueueItem
  forgeQueueItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ForgeQueueItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ForgeQueueItem_filter
  ): [ForgeQueueItem!]!
  geodeDraw(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GeodeDraw
  geodeDraws(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GeodeDraw_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GeodeDraw_filter
  ): [GeodeDraw!]!
  geodePrize(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GeodePrize
  geodePrizes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GeodePrize_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GeodePrize_filter
  ): [GeodePrize!]!
  geodeRefund(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GeodeRefund
  geodeRefunds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GeodeRefund_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GeodeRefund_filter
  ): [GeodeRefund!]!
  gotchi(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Gotchi
  gotchis(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Gotchi_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Gotchi_filter
  ): [Gotchi!]!
  item(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Item
  itemForged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ItemForged
  itemForgeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ItemForged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ItemForged_filter
  ): [ItemForged!]!
  itemSmelted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ItemSmelted
  itemSmelteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ItemSmelted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ItemSmelted_filter
  ): [ItemSmelted!]!
  items(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Item_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Item_filter
  ): [Item!]!
  vrfRequestResponse(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VrfRequestResponse
  vrfRequestResponses(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VrfRequestResponse_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VrfRequestResponse_filter
  ): [VrfRequestResponse!]!
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Account_filter
  ): [Account!]!
  forgeQueueItem(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ForgeQueueItem
  forgeQueueItems(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ForgeQueueItem_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ForgeQueueItem_filter
  ): [ForgeQueueItem!]!
  geodeDraw(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GeodeDraw
  geodeDraws(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GeodeDraw_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GeodeDraw_filter
  ): [GeodeDraw!]!
  geodePrize(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GeodePrize
  geodePrizes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GeodePrize_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GeodePrize_filter
  ): [GeodePrize!]!
  geodeRefund(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GeodeRefund
  geodeRefunds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GeodeRefund_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GeodeRefund_filter
  ): [GeodeRefund!]!
  gotchi(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Gotchi
  gotchis(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Gotchi_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Gotchi_filter
  ): [Gotchi!]!
  item(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Item
  itemForged(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ItemForged
  itemForgeds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ItemForged_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ItemForged_filter
  ): [ItemForged!]!
  itemSmelted(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ItemSmelted
  itemSmelteds(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ItemSmelted_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ItemSmelted_filter
  ): [ItemSmelted!]!
  items(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Item_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Item_filter
  ): [Item!]!
  vrfRequestResponse(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VrfRequestResponse
  vrfRequestResponses(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VrfRequestResponse_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VrfRequestResponse_filter
  ): [VrfRequestResponse!]!
}

"A string representation of microseconds UNIX timestamp (16 digits)\n"
scalar Timestamp

type VrfRequestResponse {
  blockNumber: BigInt!

  """ Tx Hash + logIndex + Request ID """
  id: ID!
  randomNumber: BigInt!
  requestId: Bytes!
  user: Account!
}

input VrfRequestResponse_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [VrfRequestResponse_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [VrfRequestResponse_filter]
  randomNumber: BigInt
  randomNumber_gt: BigInt
  randomNumber_gte: BigInt
  randomNumber_in: [BigInt!]
  randomNumber_lt: BigInt
  randomNumber_lte: BigInt
  randomNumber_not: BigInt
  randomNumber_not_in: [BigInt!]
  requestId: Bytes
  requestId_contains: Bytes
  requestId_gt: Bytes
  requestId_gte: Bytes
  requestId_in: [Bytes!]
  requestId_lt: Bytes
  requestId_lte: Bytes
  requestId_not: Bytes
  requestId_not_contains: Bytes
  requestId_not_in: [Bytes!]
  user: String
  user_: Account_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum VrfRequestResponse_orderBy {
  blockNumber
  id
  randomNumber
  requestId
  user
  user__id
  user__totalItemsForged
  user__totalItemsSmelted
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """The hash of the parent block"""
  parentHash: Bytes

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}